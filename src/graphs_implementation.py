# -*- coding: utf-8 -*-
"""graphs_implementation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1no1woho5MUzJA0iYJsO8Jv9mhpFKJwKE
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from tqdm import tqdm
from typing import Callable


WEIBULL_K_0 = 0.5
WEIBULL_LAMBDA_0 = 1 / np.sqrt(10)

GAMMA_K_0 = 0.5
GAMMA_LAMBDA_0 = 1 / np.sqrt(2)

def gen_weibull_points(num_points: int, k: float = WEIBULL_K_0, lambd: float = WEIBULL_LAMBDA_0) -> np.ndarray[np.float64]:
    """ Возвращает num_points точек сгенерированных по распределению Вейбулла W(k, lambd) """
    return lambd * np.random.weibull(k, num_points)


def gen_gamma_points(num_points: int, k: float = GAMMA_K_0, lambd: float = GAMMA_LAMBDA_0) -> np.ndarray[np.float64]:
    """ Возвращает num_points точек сгенерированных по гамма-распределению Gamm(k, lambd)"""
    return np.random.gamma(k, lambd, num_points)


class Graph:
    def __init__(self, points: np.ndarray[float], edges: set[tuple[int, int]] = set()) -> None:
        self.V = points
        self.E = [sorted(edge) for edge in edges]
        self.nx_obj = nx.empty_graph(len(points))
        self.nx_obj.add_edges_from(edges)


    def build_KNN_graph(self, K: int) -> None:
        """ Строит ребра KNN графа """
        self.E = set()

        for idx_1, x_1 in enumerate(self.V):
            dist = []
            for idx_2, x_2 in enumerate(self.V):
                dist.append([np.linalg.norm(x_1 - x_2), idx_2])
            for nearest in sorted(dist)[1:K+1]:
                self.E.add( (min(idx_1, nearest[1]), max(idx_1, nearest[1])) )

        self.nx_obj.clear_edges()
        self.nx_obj.add_edges_from(self.E)

    def build_dist_graph(self, max_dist: int) -> None:
        """ Строит ребра Distance графа """
        self.E = set()

        for idx_1, x_1 in enumerate(self.V):
            dist = []
            for idx_2, x_2 in enumerate(self.V):
                if (idx_2 <= idx_1):
                    continue
                if np.linalg.norm(x_1 - x_2) <= max_dist:
                    self.E.add( (idx_1, idx_2) )

        self.nx_obj.clear_edges()
        self.nx_obj.add_edges_from(self.E)

    def draw(self) -> None:
        """ Рисует граф """
        if (len(self.V) == 0):
            print("Пустой граф.")
            return

        for e in self.E:
            x1, y1 = self.V[e[0]], e[0]
            x2, y2 = self.V[e[1]], e[1]
            plt.plot([x1, x2], [y1, y2], 'b-', linewidth=1)
        plt.scatter(self.V, range(len(self.V)), color="blue")
        plt.title("Наш граф")
        plt.xlabel("Ее координата")
        plt.ylabel("Номер вершины")


def calculate_min_deg(G: Graph) -> int:
    """ Возвращает минимальную степень вершин графа """
    min_degree_node, min_degree = min(G.nx_obj.degree(), key=lambda x: x[1])
    return min_degree

def calculate_max_deg(G: Graph) -> int:
    """ Возвращает максимальную степень вершин графа """
    max_degree_node, max_degree = max(G.nx_obj.degree(), key=lambda x: x[1])
    return max_degree

def calculate_number_component(G: Graph) -> int:
    """ Возвращает число компонент связности графа """
    return nx.number_connected_components(G.nx_obj)

def calculate_number_articul(G: Graph) -> int:
    """ Возвращает число точек сочленения графа """
    return len(list(nx.articulation_points(G.nx_obj)))

def calculate_number_triangle(G: Graph) -> int:
    """ Возвращает число треугольников графа """
    triangles_dict =  nx.triangles(G.nx_obj)
    return sum(triangles_dict.values()) // 3

def calculate_clique_number(G: Graph) -> int:
    """ Возвращает кликовое число графа """
    max_cliques = list(nx.find_cliques(G.nx_obj))
    return max([len(clique) for clique in max_cliques])

def calculate_maxsize_independed_set(G: Graph) -> int:
    """ Возвращает размер максимального независемого множества """
    V_compl = G.V
    E_compl = set()
    for i in range(len(G.V)):
        for j in range(i + 1, len(G.V)):
            if [i, j] not in G.E:
                E_compl.add((i, j))
    G_compl = Graph(V_compl, E_compl)
    return calculate_clique_number(G_compl)

human_readable_characts = {"calculate_min_deg": "Минимальная степень вершины",
                           "calculate_max_deg": "Максимальная степень вершины",
                           "calculate_number_component": "Количество компонент связности",
                           "calculate_number_articul": "Количество точек сочленения",
                           "calculate_number_triangle": "Количество треугольников",
                           "calculate_clique_number": "Кликовое число",
                           "calculate_maxsize_independed_set": "Размер наибольшего независимого множества" }


def evaluate(
        num_samples: int = 420,                                 # количество реализация характеристики
        vector_size: int = 42,                                  # размерность случайного вектора
        gamma_k: float = GAMMA_K_0,                             # параметр k гамма-распределения
        gamma_lambda: float = GAMMA_LAMBDA_0,                   # параметр lambda гамма-распределения
        weibull_k: float = WEIBULL_K_0,                         # параметр k распределения Вейбулла
        weibull_lambda: float = WEIBULL_LAMBDA_0,               # параметр lambda распределения Вейбулла
        T_knn_foo: Callable[[Graph], int] = calculate_max_deg,  # функция вычисления характеристики для KNN графа
        knn_num_neighbours: int = 42,                           # количество соседей KNN графа
        T_dist_foo: Callable[[Graph], int] = calculate_max_deg, # функция вычисления характеристики для Distance графа
        dist_max_dist: int = 4.2,                               # макисмальная длина соединения Distance графа
        draw_distributions: bool = False                        # рисовать ли гистограммы распределения
) -> dict[str: list]:
    """
    Несколько раз симмулирует реализацию случайного вектора с некоторыми параметрами.
    Строит по ним KNN и Distance графы с некоторыми параметрами процедуры построения,
    вычисляет на них характеристики и визуализирует их распределение.
    Возвращает списки получившихся характеристик.
    """
    T_knn_gamma_list, T_knn_weibull_list = [], []
    T_dist_gamma_list, T_dist_weibull_list = [], []

    for i in range(num_samples):
        gamma_sample = gen_gamma_points(vector_size, gamma_k, gamma_lambda)
        weibull_sample = gen_weibull_points(vector_size, weibull_k, weibull_lambda)

        G_knn_gamma = Graph(points = gamma_sample)
        G_knn_gamma.build_KNN_graph(K = knn_num_neighbours)
        T_knn_gamma_list.append(T_knn_foo(G = G_knn_gamma))

        G_knn_weibull = Graph(points = weibull_sample)
        G_knn_weibull.build_KNN_graph(K = knn_num_neighbours)
        T_knn_weibull_list.append(T_knn_foo(G = G_knn_weibull))

        G_dist_gamma = Graph(points = gamma_sample)
        G_dist_gamma.build_dist_graph(max_dist = dist_max_dist)
        T_dist_gamma_list.append(T_dist_foo(G = G_dist_gamma))

        G_dist_weibull = Graph(points = weibull_sample)
        G_dist_weibull.build_dist_graph(max_dist = dist_max_dist)
        T_dist_weibull_list.append(T_dist_foo(G = G_dist_weibull))

    if draw_distributions:
        plt.figure(figsize=(16, 3))


        plt.subplot(1, 2, 1)
        plt.title(f"Распределение характеристики \'{human_readable_characts[T_knn_foo.__name__]}\' \nKNN граф.       " +
                  f"K={knn_num_neighbours} \n\nWeibull( {weibull_k},  {weibull_lambda} ) \nГ( { gamma_k},  {gamma_lambda} )")
        bins = np.arange(min(T_knn_gamma_list + T_knn_weibull_list), max(T_knn_gamma_list + T_knn_weibull_list) + 1, 1)
        plt.hist(T_knn_gamma_list, bins=bins, align="mid", alpha = 0.5, label="Гамма распределение")
        plt.hist(T_knn_weibull_list, bins=bins, align="mid", alpha = 0.5, label="Распределение Вейбулла")
        plt.xticks(bins)
        plt.xlabel("Значение характеристики")
        plt.ylabel("Количество графов")
        plt.legend()

        plt.subplot(1, 2, 2)
        plt.title(f"Распределение характеристики \'{human_readable_characts[T_dist_foo.__name__]}\' \nDistance граф.       " +
                  f"max_distance_connected={dist_max_dist} \n\nWeibull( {weibull_k},  {weibull_lambda} ) \nГ( { gamma_k},  {gamma_lambda} ) ")
        bins = np.arange(min(T_dist_gamma_list + T_dist_weibull_list), max(T_dist_gamma_list + T_dist_weibull_list) + 1, 1)
        plt.hist(T_dist_gamma_list, bins=bins, align="mid", alpha = 0.5, label="Гамма распределение")
        plt.hist(T_dist_weibull_list, bins=bins, align="mid", alpha = 0.5, label="Распределение Вейбулла")
        plt.xticks(bins)
        plt.xlabel("Значение характеристики")
        plt.ylabel("Количество графов")
        plt.legend()

        plt.show()
        print()

    return { "T_knn_gamma_lists": T_knn_gamma_list,
             "T_knn_weibull_lists": T_knn_weibull_list,
             "T_dist_gamma_lists": T_dist_gamma_list,
             "T_dist_weibull_lists": T_dist_weibull_list }